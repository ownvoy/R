---

title: "12 Tidy Data"
categories: R4DS
excerpt: 타이디 데이터
toc: true
toc_sticky: true

date: 2022-01-07
---

## 12 Tidy Data

### 12-1 Tidy data  
다음 네 가지 표를 확인 해보자.  
```r
table1
```
```r
# A tibble: 6 x 4
  country      year  cases population
  <chr>       <int>  <int>      <int>
1 Afghanistan  1999    745   19987071
2 Afghanistan  2000   2666   20595360
3 Brazil       1999  37737  172006362
4 Brazil       2000  80488  174504898
5 China        1999 212258 1272915272
6 China        2000 213766 1280428583
```
```r
table2
```
```r
# A tibble: 12 x 4
   country      year type            count
   <chr>       <int> <chr>           <int>
 1 Afghanistan  1999 cases             745
 2 Afghanistan  1999 population   19987071
 3 Afghanistan  2000 cases            2666
 4 Afghanistan  2000 population   20595360
 5 Brazil       1999 cases           37737
 6 Brazil       1999 population  172006362
 7 Brazil       2000 cases           80488
 8 Brazil       2000 population  174504898
 9 China        1999 cases          212258
10 China        1999 population 1272915272
11 China        2000 cases          213766
12 China        2000 population 1280428583
```
```r
table3
```
```r
# A tibble: 6 x 3
  country      year rate
* <chr>       <int> <chr>
1 Afghanistan  1999 745/19987071
2 Afghanistan  2000 2666/20595360
3 Brazil       1999 37737/172006362
4 Brazil       2000 80488/174504898
5 China        1999 212258/1272915272
6 China        2000 213766/1280428583
```
```r
table4a  # cases
```
```r
# A tibble: 3 x 3
  country     `1999` `2000`
* <chr>        <int>  <int>
1 Afghanistan    745   2666
2 Brazil       37737  80488
3 China       212258 213766
```
```r
table4b  # population  
```
```r
# A tibble: 3 x 3
  country         `1999`     `2000`
* <chr>            <int>      <int>
1 Afghanistan   19987071   20595360
2 Brazil       172006362  174504898
3 China       1272915272 1280428583
```

각각의 표들은 country, year, population, cases의 value들을 다른 방식으로 구성했다.  

tidy한 data들은 다음과 같은 특징을 가지고 있다.  

- 각각의 variable은 자신만의 collumn을 가지고 있다.  
- 각각의 observation은 자신만의 row를 가지고 있다.  
- 각각의 value는 자신만의 cell을 가지고 있다.  

![제목 없음](https://user-images.githubusercontent.com/96481582/148475755-a3df3a76-9fc5-4cda-96ba-f096e9bad27b.png)

(~~각각의 규칙들은 연관되어있다.~~)  

위 표들 중에서는 `table1`만 __tidy__ 하다. 

왜 data가 tidy한게 좋을까?  
첫째로 data가 uniformity를 가지고 있으면 tool로 다루기 쉽다. 두번째로는 많은 R에 내장되어 있는 함수들은 vector안에 저장된 value를 이용하기 떄문이다.  

다음은 tidy한 data를 R에 있는 함수들로 갖고 논 것이다.  
```r
table1 %>% 
  mutate(rate = cases / population * 10000)
```
```r
# A tibble: 6 x 5
  country      year  cases population  rate
  <chr>       <int>  <int>      <int> <dbl>
1 Afghanistan  1999    745   19987071 0.373
2 Afghanistan  2000   2666   20595360 1.29
3 Brazil       1999  37737  172006362 2.19 
4 Brazil       2000  80488  174504898 4.61
5 China        1999 212258 1272915272 1.67
6 China        2000 213766 1280428583 1.67
```
```r
table1 %>% 
  count(year, wt = cases)
```
```r
# A tibble: 2 x 2
   year      n
  <int>  <int>
1  1999 250740
2  2000 296920
```
![plot](https://user-images.githubusercontent.com/96481582/148476657-90cca349-3930-45bc-a56c-3b79a0e3ed17.png)
<br>
<br>

### 12-2 Pivoting
안타깝게도 너가 만나는 dataset들은 tidy하지 않다.  
untidy한 상황은 대게 다음과 같다.  

- 하나의 variable이 여러개의 collumn에 걸쳐있다.  
- 하나의 observation이 여러개의 row에 걸쳐있다.  

`pivot_longer()`와 `pivot_wider()`를 사용하여 이 상황을 해결할 수 있다.  
<br>

#### 12-2-1 Longer
```r
table4a
```
```r
# A tibble: 3 x 3
  country     `1999` `2000`
* <chr>        <int>  <int>
1 Afghanistan    745   2666
2 Brazil       37737  80488
3 China       212258 213766
```

country라는 variable이 `1999`와 `2000`에 걸쳐 있는 것을 확인할 수 있다.  
따라서 이를 새롭게 __Pivot__ 할 필요가 있다.  

- `1999`와 `2000`은 value이지 variable이 아니다.  
- `1999`와 `2000`의 __name__ 은  `year`이라는 collumn 안에 들어가야 한다.  
- `1999`와 `2000`의 __value__ 는 `cases`라는 collumn에 들어가야 한다.  

```r
table4a %>% 
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "cases")
  ```
```r
# A tibble: 6 x 3
  country     year   cases
  <chr>       <chr>  <int>
1 Afghanistan 1999     745
2 Afghanistan 2000    2666
3 Brazil      1999   37737
4 Brazil      2000   80488
5 China       1999  212258
6 China       2000  213766
```
![제목 없음](https://user-images.githubusercontent.com/96481582/148481063-551aab53-d592-4ba9-8fe0-9ca4f769d8f3.png)


~~1999와 2000은 syntatic name이 아니기에 backticks를 활용한다.~~  
위와 같은 방법을 활용하여 `table4b`도 tidy하게 만들 수 있다.  

```r
table4b %>% 
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "population")
  ```
```r
# A tibble: 6 x 3
  country     year  population
  <chr>       <chr>      <int>
1 Afghanistan 1999    19987071
2 Afghanistan 2000    20595360
3 Brazil      1999   172006362
4 Brazil      2000   174504898
5 China       1999  1272915272
6 China       2000  1280428583
```

이제 내가 하고 싶은 것은 __tidy__ 한 버전의 `table4a`와 `table4b`를 합치는 것이다.  
그렇기 위해서는 `dplyr::left_join()`를 사용해보도록 하자.
(~~13장 relational data에서 구체적으로 배운다.~~)

```r
tidy4a <- table4a %>% 
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "cases")
tidy4b <- table4b %>% 
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "population")
left_join(tidy4a, tidy4b)
```
```r
Joining, by = c("country", "year")
# A tibble: 6 x 4
  country     year   cases population
  <chr>       <chr>  <int>      <int>
1 Afghanistan 1999     745   19987071
2 Afghanistan 2000    2666   20595360
3 Brazil      1999   37737  172006362
4 Brazil      2000   80488  174504898
5 China       1999  212258 1272915272
6 China       2000  213766 1280428583
```
<br>

#### 12-2-2 Wider
`pivot_longer`은 observation이 여러개의 row에 걸쳐있을 때 사용할 수 있다.  
`table2`를 보면 year별로 2개의 row로 나누어진 것을 확인할 수 있다.  
```r
# A tibble: 12 x 4
   country      year type            count
   <chr>       <int> <chr>           <int>
 1 Afghanistan  1999 cases             745
 2 Afghanistan  1999 population   19987071
 3 Afghanistan  2000 cases            2666
 4 Afghanistan  2000 population   20595360
 5 Brazil       1999 cases           37737
 6 Brazil       1999 population  172006362
 7 Brazil       2000 cases           80488
 8 Brazil       2000 population  174504898
 9 China        1999 cases          212258
10 China        1999 population 1272915272
11 China        2000 cases          213766
12 China        2000 population 1280428583
```
이는 다음과 같이 해결할 수 있다.  

- `type`이라는 collumn에서 name을 뽑아온다.
- `count`라는 collumn에서 value를 뽑아온다.  

```r
table2 %>%
    pivot_wider(names_from = type, values_from = count)
```
```r
# A tibble: 6 x 4
  country      year  cases population
  <chr>       <int>  <int>      <int>
1 Afghanistan  1999    745   19987071
2 Afghanistan  2000   2666   20595360
3 Brazil       1999  37737  172006362
4 Brazil       2000  80488  174504898
5 China        1999 212258 1272915272
6 China        2000 213766 1280428583
```
![제목 없음](https://user-images.githubusercontent.com/96481582/148481609-abbf4d5d-3a52-40bb-a085-3488c7c979dd.png)
<br>
<br>

### 12-3  Separating and uniting
이제 `table3`만 해결하면 된다. `table3`의 문제는 하나의 column (`rate`)에 2개의 variables (`cases` 와 `population`)이 있다는 것이다.  

이를 해결하기 위해서는 `separate()`를 사용하면 된다.  

```r
table3
```
```r
# A tibble: 6 x 3
  country      year rate
* <chr>       <int> <chr>
1 Afghanistan  1999 745/19987071     
2 Afghanistan  2000 2666/20595360
3 Brazil       1999 37737/172006362
4 Brazil       2000 80488/174504898
5 China        1999 212258/1272915272
6 China        2000 213766/1280428583
```
<br>

#### 12-3-1 Separating
`seperate()`은 하나의 collumn을 2개로 나눈다. 
`seperate()`은 나눌 collumn을 정한 다음, 어디로 into할지 정한다. 
```r
table3 %>% 
  separate(rate, into = c("cases", "population"))
  ```

```r
# A tibble: 6 x 4
  country      year cases  population
  <chr>       <int> <chr>  <chr>
1 Afghanistan  1999 745    19987071
2 Afghanistan  2000 2666   20595360
3 Brazil       1999 37737  172006362
4 Brazil       2000 80488  174504898
5 China        1999 212258 1272915272
6 China        2000 213766 1280428583
```
![제목 없음](https://user-images.githubusercontent.com/96481582/148482807-741b993f-abf5-4395-a9a1-497dd71c8045.png)

`seperate()`은 default로  non-alphanumeric character를 보기만 하면 찢는다. 예를들어 위의 코드에서는 forward slash character가 rate에 있었기 때문에 나누어진 것을 확인할 수 있다. 이 character을 특별히 지정하기 위해서는 `sep`를 사용하면 된다.  

위의 코드는 다음과 같이 다시 작성 될 수 있다.  
```r
table3 %>% 
  separate(rate, into = c("cases", "population"), sep = "/")
  ```
<br>

seperate된 함수를 보면 `cases`와 `population`이 character collumn인 것을 볼 수 있다. 그러나 실제로는 integer 이다. 이는 collumn의 이름을 그대로 따라가기 때문에 생긴 문제이다.  
`convert = TRUE`를 사용하여 이를 해결할 수 있다.  

```r
table3 %>% 
  separate(rate, into = c("cases", "population"), convert = TRUE)
  ```
```r
# A tibble: 6 x 4
  country      year  cases population
  <chr>       <int>  <int>      <int>
1 Afghanistan  1999    745   19987071
2 Afghanistan  2000   2666   20595360
3 Brazil       1999  37737  172006362
4 Brazil       2000  80488  174504898
5 China        1999 212258 1272915272
6 China        2000 213766 1280428583
```
intger을 쪼갤 수도 있다. 예를 들어 2000년을 20////00으로 표현하고 싶을 수도 있다. 
이는 `sep`에 길이를 지정함으로써 할 수 있다.  

```r
table3 %>% 
  separate(year, into = c("century", "year"), sep = 2)
```
```r
# A tibble: 6 x 4
  country     century year  rate
  <chr>       <chr>   <chr> <chr>
1 Afghanistan 19      99    745/19987071
2 Afghanistan 20      00    2666/20595360
3 Brazil      19      99    37737/172006362
4 Brazil      20      00    80488/174504898
5 China       19      99    212258/1272915272
6 China       20      00    213766/1280428583
```
